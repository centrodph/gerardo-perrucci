"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[581],{683:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(4848),a=t(8453);const i={slug:"nextjs/nextjs-14-nextjs-13-handling-forms",title:"Handling Forms in Next.js 13+ with Server Actions",authors:["me"],tags:["React","Nextjs","Forms"]},o="Handling Forms in Next.js 13+ with Server Actions",s={permalink:"/gerardo-perrucci/blog/nextjs/nextjs-14-nextjs-13-handling-forms",source:"@site/blog/nextjs/2024-08-23-nextjs-handling-forms.md",title:"Handling Forms in Next.js 13+ with Server Actions",description:"Next.js 13 introduced Server Actions, which provide a powerful way to handle form submissions directly on the server.",date:"2024-08-23T00:00:00.000Z",tags:[{label:"React",permalink:"/gerardo-perrucci/blog/tags/react"},{label:"Nextjs",permalink:"/gerardo-perrucci/blog/tags/nextjs"},{label:"Forms",permalink:"/gerardo-perrucci/blog/tags/forms"}],readingTime:3.14,hasTruncateMarker:!0,authors:[{name:"Gerardo Perrucci",title:"Software Engineer",url:"https://github.com/centrodph",imageURL:"https://avatars.githubusercontent.com/u/2073951?v=4",key:"me"}],frontMatter:{slug:"nextjs/nextjs-14-nextjs-13-handling-forms",title:"Handling Forms in Next.js 13+ with Server Actions",authors:["me"],tags:["React","Nextjs","Forms"]},unlisted:!1,prevItem:{title:"Animate transition from display: none to display: block",permalink:"/gerardo-perrucci/blog/css/animate-transition-from-display-none"},nextItem:{title:"Machine Learning Visualization Missing Values",permalink:"/gerardo-perrucci/blog/machine-learning/visualization-missing-values"}},c={authorsImageUrls:[void 0]},l=[{value:"Versions",id:"versions",level:2},{value:"Setting Up the Form",id:"setting-up-the-form",level:2},{value:"Creating a Server Action",id:"creating-a-server-action",level:2},{value:"Integrating the Form and Action",id:"integrating-the-form-and-action",level:2},{value:"Handling Loading States",id:"handling-loading-states",level:2},{value:"Applying Validations",id:"applying-validations",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"Next.js 13 introduced Server Actions, which provide a powerful way to handle form submissions directly on the server."}),"\n",(0,r.jsx)(e.p,{children:"This article will guide you through creating a form, handling submissions, showing loading states, and applying validations."}),"\n",(0,r.jsx)(e.h2,{id:"versions",children:"Versions"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Next.js: 13.4 or later"}),"\n",(0,r.jsx)(e.li,{children:"Material-UI: 5.x"}),"\n",(0,r.jsx)(e.li,{children:"React: 18.x"}),"\n",(0,r.jsx)(e.li,{children:"Zod (for validation): 3.x"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"setting-up-the-form",children:"Setting Up the Form"}),"\n",(0,r.jsx)(e.p,{children:"First, let's create a form component using Material-UI:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'import { Button, TextField, Stack } from "@mui/material";\nimport { useFormStatus } from "react-dom";\n\nexport function AccountEditForm({ account, onSubmit }) {\n  const { pending } = useFormStatus();\n\n  return (\n    <form action={onSubmit}>\n      <Stack spacing={2}>\n        <TextField\n          name="name"\n          label="Account Name"\n          defaultValue={account.name}\n          required\n        />\n        <TextField\n          name="balance"\n          label="Balance"\n          type="number"\n          defaultValue={account.balance}\n          required\n        />\n        <Button type="submit" variant="contained" disabled={pending}>\n          {pending ? "Saving..." : "Save Changes"}\n        </Button>\n      </Stack>\n    </form>\n  );\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"creating-a-server-action",children:"Creating a Server Action"}),"\n",(0,r.jsx)(e.p,{children:"Next, let's create a server action to handle the form submission:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'"use server";\n\nimport { z } from "zod";\nimport { revalidatePath } from "next/cache";\nimport { supaServerClient } from "@/utils/supabase/server";\n\nconst schema = z.object({\n  name: z.string().min(1, "Name is required"),\n  balance: z.number().min(0, "Balance must be non-negative"),\n});\n\nexport async function updateAccount(formData: FormData) {\n  const id = formData.get("id") as string;\n  const name = formData.get("name") as string;\n  const balance = parseFloat(formData.get("balance") as string);\n\n  const validatedData = schema.safeParse({ name, balance });\n\n  if (!validatedData.success) {\n    return { error: validatedData.error.flatten().fieldErrors };\n  }\n\n  const supabase = supaServerClient();\n  const { error } = await supabase\n    .from("account")\n    .update({ name, balance })\n    .eq("id", id);\n\n  if (error) {\n    return { error: "Failed to update account" };\n  }\n\n  revalidatePath("/dashboard/accounts");\n  return { success: true };\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"integrating-the-form-and-action",children:"Integrating the Form and Action"}),"\n",(0,r.jsx)(e.p,{children:"Now, let's update the page component to use the form and action:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'import { AccountEditForm } from "@/components/AccountEditForm";\nimport { updateAccount } from "./actions";\nimport { supaServerClient } from "@/utils/supabase/server";\nimport { Stack, Typography, Button } from "@mui/material";\nimport Link from "next/link";\nimport { paths } from "@/paths";\n\n// ... other imports and interfaces\n\nasync function ServerData({ params }: PageProps) {\n  const supabase = supaServerClient();\n  const { data: account, error } = await supabase\n    .from("account")\n    .select("*")\n    .eq("id", params.id)\n    .single();\n\n  if (error) {\n    return <Typography color="error">Failed to load account</Typography>;\n  }\n\n  return <AccountEditForm account={account} onSubmit={updateAccount} />;\n}\n\nexport default function PageEditForm(props: PageProps) {\n  return (\n    <Stack spacing={3}>\n      <Stack direction="row" justifyContent="space-between" alignItems="center">\n        <Typography variant="h4">Edit Account</Typography>\n        <Button\n          LinkComponent={Link}\n          variant="outlined"\n          href={paths.dashboard.accounts}\n        >\n          Back\n        </Button>\n      </Stack>\n      <ServerData {...props} />\n    </Stack>\n  );\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"handling-loading-states",children:"Handling Loading States"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"useFormStatus"})," hook from ",(0,r.jsx)(e.code,{children:"react-dom"})," is used in the ",(0,r.jsx)(e.code,{children:"AccountEditForm"})," component to handle the loading state. The submit button text and disabled state are updated based on the ",(0,r.jsx)(e.code,{children:"pending"})," status."]}),"\n",(0,r.jsx)(e.h2,{id:"applying-validations",children:"Applying Validations"}),"\n",(0,r.jsxs)(e.p,{children:["We use Zod for server-side validation in the ",(0,r.jsx)(e.code,{children:"updateAccount"})," action. Client-side validation can be added using a library like Formik or react-hook-form if needed."]}),"\n",(0,r.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(e.p,{children:["The server action returns errors if validation fails or if the database update fails. You can enhance the ",(0,r.jsx)(e.code,{children:"AccountEditForm"})," component to display these errors:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'import { useState } from "react";\nimport { Button, TextField, Stack, Alert } from "@mui/material";\nimport { useFormStatus } from "react-dom";\n\nexport function AccountEditForm({ account, onSubmit }) {\n  const { pending } = useFormStatus();\n  const [error, setError] = useState(null);\n\n  const handleSubmit = async (formData) => {\n    const result = await onSubmit(formData);\n    if (result.error) {\n      setError(result.error);\n    }\n  };\n\n  return (\n    <form action={handleSubmit}>\n      {error && <Alert severity="error">{JSON.stringify(error)}</Alert>}\n      {/* ... form fields ... */}\n    </form>\n  );\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(e.p,{children:"This approach leverages Next.js 13+ Server Actions to handle form submissions efficiently. It provides a seamless way to manage server-side operations, loading states, and validations while keeping the client-side code minimal."}),"\n",(0,r.jsx)(e.p,{children:"Remember to handle errors gracefully and provide clear feedback to users. You can further enhance this setup by adding client-side validations and more sophisticated error handling as needed for your specific use case."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var r=t(6540);const a={},i=r.createContext(a);function o(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);